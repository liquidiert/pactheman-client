//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.5
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using global::System.Collections.Immutable;
using global::System.Linq;
using global::Bebop.Attributes;
using global::Bebop.Runtime;
//
// This source code was auto-generated by bebopc, Version=2.0.5.
//
namespace PacTheMan.Models {
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BaseGhostAlgorithms : System.IEquatable<BaseGhostAlgorithms> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Blinky { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Clyde { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Inky { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Pinky { get; set; }

    public bool Equals(BaseGhostAlgorithms other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Blinky == other.Blinky && Clyde == other.Clyde && Inky == other.Inky && Pinky == other.Pinky;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseGhostAlgorithms baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Blinky.GetHashCode();
      hash ^= Clyde.GetHashCode();
      hash ^= Inky.GetHashCode();
      hash ^= Pinky.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseGhostAlgorithms left, BaseGhostAlgorithms right) => Equals(left, right);
    public static bool operator !=(BaseGhostAlgorithms left, BaseGhostAlgorithms  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class GhostAlgorithms : BaseGhostAlgorithms {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseGhostAlgorithms record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseGhostAlgorithms record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseGhostAlgorithms record, ref BebopWriter writer) {
      writer.WriteString(record.Blinky);
      writer.WriteString(record.Clyde);
      writer.WriteString(record.Inky);
      writer.WriteString(record.Pinky);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static GhostAlgorithms DecodeFrom(ref BebopReader reader) {

      string field0;
      field0 = reader.ReadString();
      string field1;
      field1 = reader.ReadString();
      string field2;
      field2 = reader.ReadString();
      string field3;
      field3 = reader.ReadString();
      return new GhostAlgorithms {
        Blinky = field0,
        Clyde = field1,
        Inky = field2,
        Pinky = field3,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseGhostAlgorithms, new() {
      string field0;
      field0 = reader.ReadString();
      string field1;
      field1 = reader.ReadString();
      string field2;
      field2 = reader.ReadString();
      string field3;
      field3 = reader.ReadString();
      return new T {
        Blinky = field0,
        Clyde = field1,
        Inky = field2,
        Pinky = field3,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BaseInitState : System.IEquatable<BaseInitState> {
    public const uint OpCode = 0x9;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition> GhostInitPositions { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, BasePosition> PlayerInitPositions { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BasePosition[] ScorePointInitPositions { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long> PlayerInitScores { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long> PlayerInitLives { get; set; }

    public bool Equals(BaseInitState other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (GhostInitPositions is null ? other.GhostInitPositions is null : other.GhostInitPositions is not null && GhostInitPositions.SequenceEqual(other.GhostInitPositions)) && (PlayerInitPositions is null ? other.PlayerInitPositions is null : other.PlayerInitPositions is not null && PlayerInitPositions.SequenceEqual(other.PlayerInitPositions)) && (ScorePointInitPositions is null ? other.ScorePointInitPositions is null : other.ScorePointInitPositions is not null && ScorePointInitPositions.SequenceEqual(other.ScorePointInitPositions)) && (PlayerInitScores is null ? other.PlayerInitScores is null : other.PlayerInitScores is not null && PlayerInitScores.SequenceEqual(other.PlayerInitScores)) && (PlayerInitLives is null ? other.PlayerInitLives is null : other.PlayerInitLives is not null && PlayerInitLives.SequenceEqual(other.PlayerInitLives));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseInitState baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= GhostInitPositions.GetHashCode();
      hash ^= PlayerInitPositions.GetHashCode();
      hash ^= ScorePointInitPositions.GetHashCode();
      hash ^= PlayerInitScores.GetHashCode();
      hash ^= PlayerInitLives.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseInitState left, BaseInitState right) => Equals(left, right);
    public static bool operator !=(BaseInitState left, BaseInitState  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class InitState : BaseInitState {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseInitState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseInitState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseInitState record, ref BebopWriter writer) {
      writer.WriteUInt32(unchecked((uint)record.GhostInitPositions.Count));
      foreach (var kv0 in record.GhostInitPositions) {
        writer.WriteString(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerInitPositions.Count));
      foreach (var kv0 in record.PlayerInitPositions) {
        writer.WriteGuid(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      {
        var length0 = unchecked((uint)record.ScorePointInitPositions.Length);
        writer.WriteUInt32(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          PacTheMan.Models.Position.EncodeInto(record.ScorePointInitPositions[i0], ref writer);
        }
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerInitScores.Count));
      foreach (var kv0 in record.PlayerInitScores) {
        writer.WriteGuid(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerInitLives.Count));
      foreach (var kv0 in record.PlayerInitLives) {
        writer.WriteGuid(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static InitState DecodeFrom(ref BebopReader reader) {

      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field1.Add(k0, v0);
        }
      }
      BasePosition[] field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new BasePosition[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          BasePosition x0;
          x0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field2[i0] = x0;
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field3;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field3 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field3.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field4;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field4 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field4.Add(k0, v0);
        }
      }
      return new InitState {
        GhostInitPositions = field0,
        PlayerInitPositions = field1,
        ScorePointInitPositions = field2,
        PlayerInitScores = field3,
        PlayerInitLives = field4,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseInitState, new() {
      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field1.Add(k0, v0);
        }
      }
      BasePosition[] field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new BasePosition[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          BasePosition x0;
          x0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field2[i0] = x0;
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field3;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field3 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field3.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field4;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field4 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field4.Add(k0, v0);
        }
      }
      return new T {
        GhostInitPositions = field0,
        PlayerInitPositions = field1,
        ScorePointInitPositions = field2,
        PlayerInitScores = field3,
        PlayerInitLives = field4,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BasePlayerState : System.IEquatable<BasePlayerState> {
    public const uint OpCode = 0x5;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BaseSessionMsg Session { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public MovingStates Direction { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long> Scores { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long> Lives { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, BasePosition> PlayerPositions { get; set; }

    public bool Equals(BasePlayerState other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session && Direction == other.Direction && (Scores is null ? other.Scores is null : other.Scores is not null && Scores.SequenceEqual(other.Scores)) && (Lives is null ? other.Lives is null : other.Lives is not null && Lives.SequenceEqual(other.Lives)) && (PlayerPositions is null ? other.PlayerPositions is null : other.PlayerPositions is not null && PlayerPositions.SequenceEqual(other.PlayerPositions));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BasePlayerState baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Session.GetHashCode();
      hash ^= Direction.GetHashCode();
      hash ^= Scores.GetHashCode();
      hash ^= Lives.GetHashCode();
      hash ^= PlayerPositions.GetHashCode();
      return hash;
    }

    public static bool operator ==(BasePlayerState left, BasePlayerState right) => Equals(left, right);
    public static bool operator !=(BasePlayerState left, BasePlayerState  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class PlayerState : BasePlayerState {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BasePlayerState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BasePlayerState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BasePlayerState record, ref BebopWriter writer) {
      PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
      writer.WriteEnum<MovingStates>(record.Direction);
      writer.WriteUInt32(unchecked((uint)record.Scores.Count));
      foreach (var kv0 in record.Scores) {
        writer.WriteGuid(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
      writer.WriteUInt32(unchecked((uint)record.Lives.Count));
      foreach (var kv0 in record.Lives) {
        writer.WriteGuid(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerPositions.Count));
      foreach (var kv0 in record.PlayerPositions) {
        writer.WriteGuid(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static PlayerState DecodeFrom(ref BebopReader reader) {

      BaseSessionMsg field0;
      field0 = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
      MovingStates field1;
      field1 = reader.ReadEnum<MovingStates>();
      System.Collections.Generic.Dictionary<System.Guid, long> field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field2.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field3;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field3 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field3.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field4;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field4 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field4.Add(k0, v0);
        }
      }
      return new PlayerState {
        Session = field0,
        Direction = field1,
        Scores = field2,
        Lives = field3,
        PlayerPositions = field4,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BasePlayerState, new() {
      BaseSessionMsg field0;
      field0 = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
      MovingStates field1;
      field1 = reader.ReadEnum<MovingStates>();
      System.Collections.Generic.Dictionary<System.Guid, long> field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field2.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field3;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field3 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field3.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field4;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field4 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field4.Add(k0, v0);
        }
      }
      return new T {
        Session = field0,
        Direction = field1,
        Scores = field2,
        Lives = field3,
        PlayerPositions = field4,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BaseScorePointState : System.IEquatable<BaseScorePointState> {
    public const uint OpCode = 0x12;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BasePosition[] ScorePointPositions { get; set; }

    public bool Equals(BaseScorePointState other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (ScorePointPositions is null ? other.ScorePointPositions is null : other.ScorePointPositions is not null && ScorePointPositions.SequenceEqual(other.ScorePointPositions));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseScorePointState baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= ScorePointPositions.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseScorePointState left, BaseScorePointState right) => Equals(left, right);
    public static bool operator !=(BaseScorePointState left, BaseScorePointState  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class ScorePointState : BaseScorePointState {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseScorePointState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseScorePointState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseScorePointState record, ref BebopWriter writer) {
      {
        var length0 = unchecked((uint)record.ScorePointPositions.Length);
        writer.WriteUInt32(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          PacTheMan.Models.Position.EncodeInto(record.ScorePointPositions[i0], ref writer);
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseScorePointState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ScorePointState Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseScorePointState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ScorePointState Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseScorePointState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ScorePointState Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseScorePointState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ScorePointState Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseScorePointState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ScorePointState Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static ScorePointState DecodeFrom(ref BebopReader reader) {

      BasePosition[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new BasePosition[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          BasePosition x0;
          x0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0[i0] = x0;
        }
      }
      return new ScorePointState {
        ScorePointPositions = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseScorePointState, new() {
      BasePosition[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new BasePosition[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          BasePosition x0;
          x0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0[i0] = x0;
        }
      }
      return new T {
        ScorePointPositions = field0,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BaseErrorMsg : System.IEquatable<BaseErrorMsg> {
    public const uint OpCode = 0x1;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string ErrorMessage { get; set; }

    public bool Equals(BaseErrorMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return ErrorMessage == other.ErrorMessage;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseErrorMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= ErrorMessage.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseErrorMsg left, BaseErrorMsg right) => Equals(left, right);
    public static bool operator !=(BaseErrorMsg left, BaseErrorMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class ErrorMsg : BaseErrorMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseErrorMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseErrorMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseErrorMsg record, ref BebopWriter writer) {
      writer.WriteString(record.ErrorMessage);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseErrorMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ErrorMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseErrorMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ErrorMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseErrorMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ErrorMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseErrorMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ErrorMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseErrorMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ErrorMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static ErrorMsg DecodeFrom(ref BebopReader reader) {

      string field0;
      field0 = reader.ReadString();
      return new ErrorMsg {
        ErrorMessage = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseErrorMsg, new() {
      string field0;
      field0 = reader.ReadString();
      return new T {
        ErrorMessage = field0,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BaseExitMsg : System.IEquatable<BaseExitMsg> {
    public const uint OpCode = 0x3;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BaseSessionMsg Session { get; set; }

    public bool Equals(BaseExitMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseExitMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Session.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseExitMsg left, BaseExitMsg right) => Equals(left, right);
    public static bool operator !=(BaseExitMsg left, BaseExitMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class ExitMsg : BaseExitMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseExitMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseExitMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseExitMsg record, ref BebopWriter writer) {
      PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseExitMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ExitMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseExitMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ExitMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseExitMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ExitMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseExitMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ExitMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseExitMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ExitMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static ExitMsg DecodeFrom(ref BebopReader reader) {

      BaseSessionMsg field0;
      field0 = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
      return new ExitMsg {
        Session = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseExitMsg, new() {
      BaseSessionMsg field0;
      field0 = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
      return new T {
        Session = field0,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BaseGhostMoveMsg : System.IEquatable<BaseGhostMoveMsg> {
    public const uint OpCode = 0x6;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition> GhostPositions { get; set; }

    public bool Equals(BaseGhostMoveMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (GhostPositions is null ? other.GhostPositions is null : other.GhostPositions is not null && GhostPositions.SequenceEqual(other.GhostPositions));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseGhostMoveMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= GhostPositions.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseGhostMoveMsg left, BaseGhostMoveMsg right) => Equals(left, right);
    public static bool operator !=(BaseGhostMoveMsg left, BaseGhostMoveMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class GhostMoveMsg : BaseGhostMoveMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseGhostMoveMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseGhostMoveMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseGhostMoveMsg record, ref BebopWriter writer) {
      writer.WriteUInt32(unchecked((uint)record.GhostPositions.Count));
      foreach (var kv0 in record.GhostPositions) {
        writer.WriteString(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static GhostMoveMsg DecodeFrom(ref BebopReader reader) {

      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      return new GhostMoveMsg {
        GhostPositions = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseGhostMoveMsg, new() {
      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      return new T {
        GhostPositions = field0,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BaseJoinMsg : System.IEquatable<BaseJoinMsg> {
    public const uint OpCode = 0x4;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseSessionMsg? Session { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseGhostAlgorithms? Algorithms { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public string? PlayerName { get; set; }
    #nullable disable

    public bool Equals(BaseJoinMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session && Algorithms == other.Algorithms && PlayerName == other.PlayerName;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseJoinMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Session is not null) hash ^= Session.GetHashCode();
      if (Algorithms is not null) hash ^= Algorithms.GetHashCode();
      if (PlayerName is not null) hash ^= PlayerName.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseJoinMsg left, BaseJoinMsg right) => Equals(left, right);
    public static bool operator !=(BaseJoinMsg left, BaseJoinMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class JoinMsg : BaseJoinMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseJoinMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseJoinMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseJoinMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Session is not null) {
        writer.WriteByte(1);
        PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
      }

      if (record.Algorithms is not null) {
        writer.WriteByte(2);
        PacTheMan.Models.GhostAlgorithms.EncodeInto(record.Algorithms, ref writer);
      }

      if (record.PlayerName is not null) {
        writer.WriteByte(3);
        writer.WriteString(record.PlayerName);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseJoinMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static JoinMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseJoinMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static JoinMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseJoinMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static JoinMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseJoinMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static JoinMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseJoinMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static JoinMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static JoinMsg DecodeFrom(ref BebopReader reader) {

      var record = new JoinMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          case 2:
            record.Algorithms = PacTheMan.Models.GhostAlgorithms.DecodeFrom(ref reader);
            break;
          case 3:
            record.PlayerName = reader.ReadString();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseJoinMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          case 2:
            record.Algorithms = PacTheMan.Models.GhostAlgorithms.DecodeFrom(ref reader);
            break;
          case 3:
            record.PlayerName = reader.ReadString();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BasePlayerJoinedMsg : System.IEquatable<BasePlayerJoinedMsg> {
    public const uint OpCode = 0x7;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public string? PlayerName { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseSessionMsg? Session { get; set; }
    #nullable disable

    public bool Equals(BasePlayerJoinedMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return PlayerName == other.PlayerName && Session == other.Session;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BasePlayerJoinedMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (PlayerName is not null) hash ^= PlayerName.GetHashCode();
      if (Session is not null) hash ^= Session.GetHashCode();
      return hash;
    }

    public static bool operator ==(BasePlayerJoinedMsg left, BasePlayerJoinedMsg right) => Equals(left, right);
    public static bool operator !=(BasePlayerJoinedMsg left, BasePlayerJoinedMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class PlayerJoinedMsg : BasePlayerJoinedMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BasePlayerJoinedMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BasePlayerJoinedMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BasePlayerJoinedMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.PlayerName is not null) {
        writer.WriteByte(1);
        writer.WriteString(record.PlayerName);
      }

      if (record.Session is not null) {
        writer.WriteByte(2);
        PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BasePlayerJoinedMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerJoinedMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BasePlayerJoinedMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerJoinedMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BasePlayerJoinedMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerJoinedMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BasePlayerJoinedMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerJoinedMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BasePlayerJoinedMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerJoinedMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static PlayerJoinedMsg DecodeFrom(ref BebopReader reader) {

      var record = new PlayerJoinedMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.PlayerName = reader.ReadString();
            break;
          case 2:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BasePlayerJoinedMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.PlayerName = reader.ReadString();
            break;
          case 2:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BaseReadyMsg : System.IEquatable<BaseReadyMsg> {
    public const uint OpCode = 0x8;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseSessionMsg? Session { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public bool? Ready { get; set; }
    #nullable disable

    public bool Equals(BaseReadyMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session && Ready == other.Ready;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseReadyMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Session is not null) hash ^= Session.GetHashCode();
      if (Ready is not null) hash ^= Ready.Value.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseReadyMsg left, BaseReadyMsg right) => Equals(left, right);
    public static bool operator !=(BaseReadyMsg left, BaseReadyMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class ReadyMsg : BaseReadyMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseReadyMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseReadyMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseReadyMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Session is not null) {
        writer.WriteByte(1);
        PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
      }

      if (record.Ready is not null) {
        writer.WriteByte(2);
        writer.WriteByte(record.Ready.Value);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseReadyMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReadyMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseReadyMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReadyMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseReadyMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReadyMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseReadyMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReadyMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseReadyMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReadyMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static ReadyMsg DecodeFrom(ref BebopReader reader) {

      var record = new ReadyMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          case 2:
            record.Ready = reader.ReadByte() != 0;
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseReadyMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          case 2:
            record.Ready = reader.ReadByte() != 0;
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BaseReconnectMsg : System.IEquatable<BaseReconnectMsg> {
    public const uint OpCode = 0x11;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseSessionMsg? Session { get; set; }
    #nullable disable

    public bool Equals(BaseReconnectMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseReconnectMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Session is not null) hash ^= Session.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseReconnectMsg left, BaseReconnectMsg right) => Equals(left, right);
    public static bool operator !=(BaseReconnectMsg left, BaseReconnectMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class ReconnectMsg : BaseReconnectMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseReconnectMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseReconnectMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseReconnectMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Session is not null) {
        writer.WriteByte(1);
        PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseReconnectMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReconnectMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseReconnectMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReconnectMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseReconnectMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReconnectMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseReconnectMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReconnectMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseReconnectMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReconnectMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static ReconnectMsg DecodeFrom(ref BebopReader reader) {

      var record = new ReconnectMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseReconnectMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BaseResetMsg : System.IEquatable<BaseResetMsg> {
    public const uint OpCode = 0x10;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition> GhostResetPoints { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, BasePosition> PlayerResetPoints { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long> PlayerLives { get; set; }

    public bool Equals(BaseResetMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (GhostResetPoints is null ? other.GhostResetPoints is null : other.GhostResetPoints is not null && GhostResetPoints.SequenceEqual(other.GhostResetPoints)) && (PlayerResetPoints is null ? other.PlayerResetPoints is null : other.PlayerResetPoints is not null && PlayerResetPoints.SequenceEqual(other.PlayerResetPoints)) && (PlayerLives is null ? other.PlayerLives is null : other.PlayerLives is not null && PlayerLives.SequenceEqual(other.PlayerLives));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseResetMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= GhostResetPoints.GetHashCode();
      hash ^= PlayerResetPoints.GetHashCode();
      hash ^= PlayerLives.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseResetMsg left, BaseResetMsg right) => Equals(left, right);
    public static bool operator !=(BaseResetMsg left, BaseResetMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class ResetMsg : BaseResetMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseResetMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseResetMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseResetMsg record, ref BebopWriter writer) {
      writer.WriteUInt32(unchecked((uint)record.GhostResetPoints.Count));
      foreach (var kv0 in record.GhostResetPoints) {
        writer.WriteString(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerResetPoints.Count));
      foreach (var kv0 in record.PlayerResetPoints) {
        writer.WriteGuid(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerLives.Count));
      foreach (var kv0 in record.PlayerLives) {
        writer.WriteGuid(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseResetMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ResetMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseResetMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ResetMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseResetMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ResetMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseResetMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ResetMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseResetMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ResetMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static ResetMsg DecodeFrom(ref BebopReader reader) {

      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field1.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field2.Add(k0, v0);
        }
      }
      return new ResetMsg {
        GhostResetPoints = field0,
        PlayerResetPoints = field1,
        PlayerLives = field2,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseResetMsg, new() {
      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field1.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field2.Add(k0, v0);
        }
      }
      return new T {
        GhostResetPoints = field0,
        PlayerResetPoints = field1,
        PlayerLives = field2,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BaseNetworkMessage : System.IEquatable<BaseNetworkMessage> {
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public uint? IncomingOpCode { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public ImmutableArray<byte> IncomingRecord { get; set; }
    #nullable disable

    public bool Equals(BaseNetworkMessage other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return IncomingOpCode == other.IncomingOpCode && (IncomingRecord == null ? other.IncomingRecord == null : other.IncomingRecord != null && IncomingRecord.SequenceEqual(other.IncomingRecord));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseNetworkMessage baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (IncomingOpCode is not null) hash ^= IncomingOpCode.Value.GetHashCode();
      if (IncomingRecord != null) hash ^= IncomingRecord.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseNetworkMessage left, BaseNetworkMessage right) => Equals(left, right);
    public static bool operator !=(BaseNetworkMessage left, BaseNetworkMessage  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class NetworkMessage : BaseNetworkMessage {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseNetworkMessage record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseNetworkMessage record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseNetworkMessage record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.IncomingOpCode is not null) {
        writer.WriteByte(1);
        writer.WriteUInt32(record.IncomingOpCode.Value);
      }

      if (record.IncomingRecord != null) {
        writer.WriteByte(2);
        writer.WriteBytes(record.IncomingRecord);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static NetworkMessage DecodeFrom(ref BebopReader reader) {

      var record = new NetworkMessage();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.IncomingOpCode = reader.ReadUInt32();
            break;
          case 2:
            record.IncomingRecord = reader.ReadBytes();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseNetworkMessage, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.IncomingOpCode = reader.ReadUInt32();
            break;
          case 2:
            record.IncomingRecord = reader.ReadBytes();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public enum MovingStates : uint {
    Up = 0,
    Down = 1,
    Left = 2,
    Right = 3
  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BasePosition : System.IEquatable<BasePosition> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public float X { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public float Y { get; set; }

    public bool Equals(BasePosition other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return X == other.X && Y == other.Y;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BasePosition baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= X.GetHashCode();
      hash ^= Y.GetHashCode();
      return hash;
    }

    public static bool operator ==(BasePosition left, BasePosition right) => Equals(left, right);
    public static bool operator !=(BasePosition left, BasePosition  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class Position : BasePosition {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BasePosition record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BasePosition record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BasePosition record, ref BebopWriter writer) {
      writer.WriteFloat32(record.X);
      writer.WriteFloat32(record.Y);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Position DecodeFrom(ref BebopReader reader) {

      float field0;
      field0 = reader.ReadFloat32();
      float field1;
      field1 = reader.ReadFloat32();
      return new Position {
        X = field0,
        Y = field1,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BasePosition, new() {
      float field0;
      field0 = reader.ReadFloat32();
      float field1;
      field1 = reader.ReadFloat32();
      return new T {
        X = field0,
        Y = field1,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public abstract class BaseSessionMsg : System.IEquatable<BaseSessionMsg> {
    public const uint OpCode = 0x2;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public string? SessionId { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public System.Guid? ClientId { get; set; }
    #nullable disable

    public bool Equals(BaseSessionMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return SessionId == other.SessionId && ClientId == other.ClientId;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseSessionMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (SessionId is not null) hash ^= SessionId.GetHashCode();
      if (ClientId is not null) hash ^= ClientId.Value.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseSessionMsg left, BaseSessionMsg right) => Equals(left, right);
    public static bool operator !=(BaseSessionMsg left, BaseSessionMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.5")]
  [BebopRecord]
  public sealed class SessionMsg : BaseSessionMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseSessionMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseSessionMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseSessionMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.SessionId is not null) {
        writer.WriteByte(1);
        writer.WriteString(record.SessionId);
      }

      if (record.ClientId is not null) {
        writer.WriteByte(2);
        writer.WriteGuid(record.ClientId.Value);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static SessionMsg DecodeFrom(ref BebopReader reader) {

      var record = new SessionMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.SessionId = reader.ReadString();
            break;
          case 2:
            record.ClientId = reader.ReadGuid();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseSessionMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.SessionId = reader.ReadString();
            break;
          case 2:
            record.ClientId = reader.ReadGuid();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
}
