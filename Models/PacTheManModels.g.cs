//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using global::System.Collections.Immutable;
using global::System.Linq;
using global::Bebop.Attributes;
using global::Bebop.Runtime;
//
// This source code was auto-generated by bebopc, Version=2.0.3.
//
namespace PacTheMan.Models {
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseGhostAlgorithms : System.IEquatable<BaseGhostAlgorithms> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Blinky { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Clyde { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Inky { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Pinky { get; set; }

    public bool Equals(BaseGhostAlgorithms other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Blinky == other.Blinky && Clyde == other.Clyde && Inky == other.Inky && Pinky == other.Pinky;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseGhostAlgorithms baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Blinky.GetHashCode();
      hash ^= Clyde.GetHashCode();
      hash ^= Inky.GetHashCode();
      hash ^= Pinky.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseGhostAlgorithms left, BaseGhostAlgorithms right) => Equals(left, right);
    public static bool operator !=(BaseGhostAlgorithms left, BaseGhostAlgorithms  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class GhostAlgorithms : BaseGhostAlgorithms {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseGhostAlgorithms record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseGhostAlgorithms record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseGhostAlgorithms record, ref BebopWriter writer) {
      writer.WriteString(record.Blinky);
      writer.WriteString(record.Clyde);
      writer.WriteString(record.Inky);
      writer.WriteString(record.Pinky);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static GhostAlgorithms DecodeFrom(ref BebopReader reader) {

      string field0;
      field0 = reader.ReadString();
      string field1;
      field1 = reader.ReadString();
      string field2;
      field2 = reader.ReadString();
      string field3;
      field3 = reader.ReadString();
      return new GhostAlgorithms {
        Blinky = field0,
        Clyde = field1,
        Inky = field2,
        Pinky = field3,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseGhostAlgorithms, new() {
      string field0;
      field0 = reader.ReadString();
      string field1;
      field1 = reader.ReadString();
      string field2;
      field2 = reader.ReadString();
      string field3;
      field3 = reader.ReadString();
      return new T {
        Blinky = field0,
        Clyde = field1,
        Inky = field2,
        Pinky = field3,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseGhostState : System.IEquatable<BaseGhostState> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition> Targets { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, bool> ClearTargets { get; set; }

    public bool Equals(BaseGhostState other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (Targets is null ? other.Targets is null : other.Targets is not null && Targets.SequenceEqual(other.Targets)) && (ClearTargets is null ? other.ClearTargets is null : other.ClearTargets is not null && ClearTargets.SequenceEqual(other.ClearTargets));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseGhostState baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Targets.GetHashCode();
      hash ^= ClearTargets.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseGhostState left, BaseGhostState right) => Equals(left, right);
    public static bool operator !=(BaseGhostState left, BaseGhostState  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class GhostState : BaseGhostState {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseGhostState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseGhostState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseGhostState record, ref BebopWriter writer) {
      writer.WriteUInt32(unchecked((uint)record.Targets.Count));
      foreach (var kv0 in record.Targets) {
        writer.WriteString(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      writer.WriteUInt32(unchecked((uint)record.ClearTargets.Count));
      foreach (var kv0 in record.ClearTargets) {
        writer.WriteString(kv0.Key);
        writer.WriteByte(kv0.Value);
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseGhostState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostState Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseGhostState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostState Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseGhostState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostState Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseGhostState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostState Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseGhostState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostState Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static GhostState DecodeFrom(ref BebopReader reader) {

      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, bool> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<string, bool>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          bool v0;
          k0 = reader.ReadString();
          v0 = reader.ReadByte() != 0;
          field1.Add(k0, v0);
        }
      }
      return new GhostState {
        Targets = field0,
        ClearTargets = field1,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseGhostState, new() {
      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, bool> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<string, bool>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          bool v0;
          k0 = reader.ReadString();
          v0 = reader.ReadByte() != 0;
          field1.Add(k0, v0);
        }
      }
      return new T {
        Targets = field0,
        ClearTargets = field1,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseInitState : System.IEquatable<BaseInitState> {
    public const uint OpCode = 0x9;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long> StartReconciliationId { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition> GhostInitPositions { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, long> GhostInitDelays { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, BasePosition> PlayerInitPositions { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long> PlayerInitScores { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long> PlayerInitLives { get; set; }

    public bool Equals(BaseInitState other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (StartReconciliationId is null ? other.StartReconciliationId is null : other.StartReconciliationId is not null && StartReconciliationId.SequenceEqual(other.StartReconciliationId)) && (GhostInitPositions is null ? other.GhostInitPositions is null : other.GhostInitPositions is not null && GhostInitPositions.SequenceEqual(other.GhostInitPositions)) && (GhostInitDelays is null ? other.GhostInitDelays is null : other.GhostInitDelays is not null && GhostInitDelays.SequenceEqual(other.GhostInitDelays)) && (PlayerInitPositions is null ? other.PlayerInitPositions is null : other.PlayerInitPositions is not null && PlayerInitPositions.SequenceEqual(other.PlayerInitPositions)) && (PlayerInitScores is null ? other.PlayerInitScores is null : other.PlayerInitScores is not null && PlayerInitScores.SequenceEqual(other.PlayerInitScores)) && (PlayerInitLives is null ? other.PlayerInitLives is null : other.PlayerInitLives is not null && PlayerInitLives.SequenceEqual(other.PlayerInitLives));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseInitState baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= StartReconciliationId.GetHashCode();
      hash ^= GhostInitPositions.GetHashCode();
      hash ^= GhostInitDelays.GetHashCode();
      hash ^= PlayerInitPositions.GetHashCode();
      hash ^= PlayerInitScores.GetHashCode();
      hash ^= PlayerInitLives.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseInitState left, BaseInitState right) => Equals(left, right);
    public static bool operator !=(BaseInitState left, BaseInitState  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class InitState : BaseInitState {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseInitState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseInitState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseInitState record, ref BebopWriter writer) {
      writer.WriteUInt32(unchecked((uint)record.StartReconciliationId.Count));
      foreach (var kv0 in record.StartReconciliationId) {
        writer.WriteGuid(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
      writer.WriteUInt32(unchecked((uint)record.GhostInitPositions.Count));
      foreach (var kv0 in record.GhostInitPositions) {
        writer.WriteString(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      writer.WriteUInt32(unchecked((uint)record.GhostInitDelays.Count));
      foreach (var kv0 in record.GhostInitDelays) {
        writer.WriteString(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerInitPositions.Count));
      foreach (var kv0 in record.PlayerInitPositions) {
        writer.WriteGuid(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerInitScores.Count));
      foreach (var kv0 in record.PlayerInitScores) {
        writer.WriteGuid(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerInitLives.Count));
      foreach (var kv0 in record.PlayerInitLives) {
        writer.WriteGuid(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static InitState DecodeFrom(ref BebopReader reader) {

      System.Collections.Generic.Dictionary<System.Guid, long> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field0.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, BasePosition> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field1.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, long> field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new System.Collections.Generic.Dictionary<string, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          long v0;
          k0 = reader.ReadString();
          v0 = reader.ReadInt64();
          field2.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field3;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field3 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field3.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field4;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field4 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field4.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field5;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field5 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field5.Add(k0, v0);
        }
      }
      return new InitState {
        StartReconciliationId = field0,
        GhostInitPositions = field1,
        GhostInitDelays = field2,
        PlayerInitPositions = field3,
        PlayerInitScores = field4,
        PlayerInitLives = field5,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseInitState, new() {
      System.Collections.Generic.Dictionary<System.Guid, long> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field0.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, BasePosition> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field1.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, long> field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new System.Collections.Generic.Dictionary<string, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          long v0;
          k0 = reader.ReadString();
          v0 = reader.ReadInt64();
          field2.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field3;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field3 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field3.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field4;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field4 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field4.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field5;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field5 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field5.Add(k0, v0);
        }
      }
      return new T {
        StartReconciliationId = field0,
        GhostInitPositions = field1,
        GhostInitDelays = field2,
        PlayerInitPositions = field3,
        PlayerInitScores = field4,
        PlayerInitLives = field5,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BasePlayerState : System.IEquatable<BasePlayerState> {
    public const uint OpCode = 0x5;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BaseSessionMsg Session { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Name { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public long ReconciliationId { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long> Score { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long> Lives { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition> GhostPositions { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, BasePosition> PlayerPositions { get; set; }

    public bool Equals(BasePlayerState other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session && Name == other.Name && ReconciliationId == other.ReconciliationId && (Score is null ? other.Score is null : other.Score is not null && Score.SequenceEqual(other.Score)) && (Lives is null ? other.Lives is null : other.Lives is not null && Lives.SequenceEqual(other.Lives)) && (GhostPositions is null ? other.GhostPositions is null : other.GhostPositions is not null && GhostPositions.SequenceEqual(other.GhostPositions)) && (PlayerPositions is null ? other.PlayerPositions is null : other.PlayerPositions is not null && PlayerPositions.SequenceEqual(other.PlayerPositions));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BasePlayerState baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Session.GetHashCode();
      hash ^= Name.GetHashCode();
      hash ^= ReconciliationId.GetHashCode();
      hash ^= Score.GetHashCode();
      hash ^= Lives.GetHashCode();
      hash ^= GhostPositions.GetHashCode();
      hash ^= PlayerPositions.GetHashCode();
      return hash;
    }

    public static bool operator ==(BasePlayerState left, BasePlayerState right) => Equals(left, right);
    public static bool operator !=(BasePlayerState left, BasePlayerState  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class PlayerState : BasePlayerState {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BasePlayerState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BasePlayerState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BasePlayerState record, ref BebopWriter writer) {
      PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
      writer.WriteString(record.Name);
      writer.WriteInt64(record.ReconciliationId);
      writer.WriteUInt32(unchecked((uint)record.Score.Count));
      foreach (var kv0 in record.Score) {
        writer.WriteGuid(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
      writer.WriteUInt32(unchecked((uint)record.Lives.Count));
      foreach (var kv0 in record.Lives) {
        writer.WriteGuid(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
      writer.WriteUInt32(unchecked((uint)record.GhostPositions.Count));
      foreach (var kv0 in record.GhostPositions) {
        writer.WriteString(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerPositions.Count));
      foreach (var kv0 in record.PlayerPositions) {
        writer.WriteGuid(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static PlayerState DecodeFrom(ref BebopReader reader) {

      BaseSessionMsg field0;
      field0 = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
      string field1;
      field1 = reader.ReadString();
      long field2;
      field2 = reader.ReadInt64();
      System.Collections.Generic.Dictionary<System.Guid, long> field3;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field3 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field3.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field4;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field4 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field4.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, BasePosition> field5;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field5 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field5.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field6;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field6 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field6.Add(k0, v0);
        }
      }
      return new PlayerState {
        Session = field0,
        Name = field1,
        ReconciliationId = field2,
        Score = field3,
        Lives = field4,
        GhostPositions = field5,
        PlayerPositions = field6,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BasePlayerState, new() {
      BaseSessionMsg field0;
      field0 = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
      string field1;
      field1 = reader.ReadString();
      long field2;
      field2 = reader.ReadInt64();
      System.Collections.Generic.Dictionary<System.Guid, long> field3;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field3 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field3.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field4;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field4 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field4.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, BasePosition> field5;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field5 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field5.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field6;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field6 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field6.Add(k0, v0);
        }
      }
      return new T {
        Session = field0,
        Name = field1,
        ReconciliationId = field2,
        Score = field3,
        Lives = field4,
        GhostPositions = field5,
        PlayerPositions = field6,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseErrorMsg : System.IEquatable<BaseErrorMsg> {
    public const uint OpCode = 0x1;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string ErrorMessage { get; set; }

    public bool Equals(BaseErrorMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return ErrorMessage == other.ErrorMessage;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseErrorMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= ErrorMessage.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseErrorMsg left, BaseErrorMsg right) => Equals(left, right);
    public static bool operator !=(BaseErrorMsg left, BaseErrorMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class ErrorMsg : BaseErrorMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseErrorMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseErrorMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseErrorMsg record, ref BebopWriter writer) {
      writer.WriteString(record.ErrorMessage);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseErrorMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ErrorMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseErrorMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ErrorMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseErrorMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ErrorMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseErrorMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ErrorMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseErrorMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ErrorMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static ErrorMsg DecodeFrom(ref BebopReader reader) {

      string field0;
      field0 = reader.ReadString();
      return new ErrorMsg {
        ErrorMessage = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseErrorMsg, new() {
      string field0;
      field0 = reader.ReadString();
      return new T {
        ErrorMessage = field0,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseExitMsg : System.IEquatable<BaseExitMsg> {
    public const uint OpCode = 0x3;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BaseSessionMsg Session { get; set; }

    public bool Equals(BaseExitMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseExitMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Session.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseExitMsg left, BaseExitMsg right) => Equals(left, right);
    public static bool operator !=(BaseExitMsg left, BaseExitMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class ExitMsg : BaseExitMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseExitMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseExitMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseExitMsg record, ref BebopWriter writer) {
      PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseExitMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ExitMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseExitMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ExitMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseExitMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ExitMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseExitMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ExitMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseExitMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ExitMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static ExitMsg DecodeFrom(ref BebopReader reader) {

      BaseSessionMsg field0;
      field0 = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
      return new ExitMsg {
        Session = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseExitMsg, new() {
      BaseSessionMsg field0;
      field0 = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
      return new T {
        Session = field0,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseGhostMoveMsg : System.IEquatable<BaseGhostMoveMsg> {
    public const uint OpCode = 0x6;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseGhostState? State { get; set; }
    #nullable disable

    public bool Equals(BaseGhostMoveMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return State == other.State;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseGhostMoveMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (State is not null) hash ^= State.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseGhostMoveMsg left, BaseGhostMoveMsg right) => Equals(left, right);
    public static bool operator !=(BaseGhostMoveMsg left, BaseGhostMoveMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class GhostMoveMsg : BaseGhostMoveMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseGhostMoveMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseGhostMoveMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseGhostMoveMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.State is not null) {
        writer.WriteByte(1);
        PacTheMan.Models.GhostState.EncodeInto(record.State, ref writer);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static GhostMoveMsg DecodeFrom(ref BebopReader reader) {

      var record = new GhostMoveMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.State = PacTheMan.Models.GhostState.DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseGhostMoveMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.State = PacTheMan.Models.GhostState.DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseJoinMsg : System.IEquatable<BaseJoinMsg> {
    public const uint OpCode = 0x4;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseSessionMsg? Session { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseGhostAlgorithms? Algorithms { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public string? PlayerName { get; set; }
    #nullable disable

    public bool Equals(BaseJoinMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session && Algorithms == other.Algorithms && PlayerName == other.PlayerName;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseJoinMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Session is not null) hash ^= Session.GetHashCode();
      if (Algorithms is not null) hash ^= Algorithms.GetHashCode();
      if (PlayerName is not null) hash ^= PlayerName.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseJoinMsg left, BaseJoinMsg right) => Equals(left, right);
    public static bool operator !=(BaseJoinMsg left, BaseJoinMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class JoinMsg : BaseJoinMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseJoinMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseJoinMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseJoinMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Session is not null) {
        writer.WriteByte(1);
        PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
      }

      if (record.Algorithms is not null) {
        writer.WriteByte(2);
        PacTheMan.Models.GhostAlgorithms.EncodeInto(record.Algorithms, ref writer);
      }

      if (record.PlayerName is not null) {
        writer.WriteByte(3);
        writer.WriteString(record.PlayerName);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseJoinMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static JoinMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseJoinMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static JoinMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseJoinMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static JoinMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseJoinMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static JoinMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseJoinMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static JoinMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static JoinMsg DecodeFrom(ref BebopReader reader) {

      var record = new JoinMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          case 2:
            record.Algorithms = PacTheMan.Models.GhostAlgorithms.DecodeFrom(ref reader);
            break;
          case 3:
            record.PlayerName = reader.ReadString();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseJoinMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          case 2:
            record.Algorithms = PacTheMan.Models.GhostAlgorithms.DecodeFrom(ref reader);
            break;
          case 3:
            record.PlayerName = reader.ReadString();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BasePlayerJoinedMsg : System.IEquatable<BasePlayerJoinedMsg> {
    public const uint OpCode = 0x7;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public string? PlayerName { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseSessionMsg? Session { get; set; }
    #nullable disable

    public bool Equals(BasePlayerJoinedMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return PlayerName == other.PlayerName && Session == other.Session;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BasePlayerJoinedMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (PlayerName is not null) hash ^= PlayerName.GetHashCode();
      if (Session is not null) hash ^= Session.GetHashCode();
      return hash;
    }

    public static bool operator ==(BasePlayerJoinedMsg left, BasePlayerJoinedMsg right) => Equals(left, right);
    public static bool operator !=(BasePlayerJoinedMsg left, BasePlayerJoinedMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class PlayerJoinedMsg : BasePlayerJoinedMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BasePlayerJoinedMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BasePlayerJoinedMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BasePlayerJoinedMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.PlayerName is not null) {
        writer.WriteByte(1);
        writer.WriteString(record.PlayerName);
      }

      if (record.Session is not null) {
        writer.WriteByte(2);
        PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BasePlayerJoinedMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerJoinedMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BasePlayerJoinedMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerJoinedMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BasePlayerJoinedMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerJoinedMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BasePlayerJoinedMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerJoinedMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BasePlayerJoinedMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerJoinedMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static PlayerJoinedMsg DecodeFrom(ref BebopReader reader) {

      var record = new PlayerJoinedMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.PlayerName = reader.ReadString();
            break;
          case 2:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BasePlayerJoinedMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.PlayerName = reader.ReadString();
            break;
          case 2:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseReadyMsg : System.IEquatable<BaseReadyMsg> {
    public const uint OpCode = 0x8;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseSessionMsg? Session { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public bool? Ready { get; set; }
    #nullable disable

    public bool Equals(BaseReadyMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session && Ready == other.Ready;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseReadyMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Session is not null) hash ^= Session.GetHashCode();
      if (Ready is not null) hash ^= Ready.Value.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseReadyMsg left, BaseReadyMsg right) => Equals(left, right);
    public static bool operator !=(BaseReadyMsg left, BaseReadyMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class ReadyMsg : BaseReadyMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseReadyMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseReadyMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseReadyMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Session is not null) {
        writer.WriteByte(1);
        PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
      }

      if (record.Ready is not null) {
        writer.WriteByte(2);
        writer.WriteByte(record.Ready.Value);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseReadyMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReadyMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseReadyMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReadyMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseReadyMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReadyMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseReadyMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReadyMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseReadyMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ReadyMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static ReadyMsg DecodeFrom(ref BebopReader reader) {

      var record = new ReadyMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          case 2:
            record.Ready = reader.ReadByte() != 0;
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseReadyMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          case 2:
            record.Ready = reader.ReadByte() != 0;
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseResetMsg : System.IEquatable<BaseResetMsg> {
    public const uint OpCode = 0x10;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition>? GhostResetPoints { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public System.Collections.Generic.Dictionary<System.Guid, BasePosition>? PlayerResetPoints { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long>? PlayerLives { get; set; }
    #nullable disable

    public bool Equals(BaseResetMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (GhostResetPoints is null ? other.GhostResetPoints is null : other.GhostResetPoints is not null && GhostResetPoints.SequenceEqual(other.GhostResetPoints)) && (PlayerResetPoints is null ? other.PlayerResetPoints is null : other.PlayerResetPoints is not null && PlayerResetPoints.SequenceEqual(other.PlayerResetPoints)) && (PlayerLives is null ? other.PlayerLives is null : other.PlayerLives is not null && PlayerLives.SequenceEqual(other.PlayerLives));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseResetMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (GhostResetPoints is not null) hash ^= GhostResetPoints.GetHashCode();
      if (PlayerResetPoints is not null) hash ^= PlayerResetPoints.GetHashCode();
      if (PlayerLives is not null) hash ^= PlayerLives.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseResetMsg left, BaseResetMsg right) => Equals(left, right);
    public static bool operator !=(BaseResetMsg left, BaseResetMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class ResetMsg : BaseResetMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseResetMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseResetMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseResetMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.GhostResetPoints is not null) {
        writer.WriteByte(1);
        writer.WriteUInt32(unchecked((uint)record.GhostResetPoints.Count));
        foreach (var kv0 in record.GhostResetPoints) {
          writer.WriteString(kv0.Key);
          PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
        }
      }

      if (record.PlayerResetPoints is not null) {
        writer.WriteByte(2);
        writer.WriteUInt32(unchecked((uint)record.PlayerResetPoints.Count));
        foreach (var kv0 in record.PlayerResetPoints) {
          writer.WriteGuid(kv0.Key);
          PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
        }
      }

      if (record.PlayerLives is not null) {
        writer.WriteByte(3);
        writer.WriteUInt32(unchecked((uint)record.PlayerLives.Count));
        foreach (var kv0 in record.PlayerLives) {
          writer.WriteGuid(kv0.Key);
          writer.WriteInt64(kv0.Value);
        }
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseResetMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ResetMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseResetMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ResetMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseResetMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ResetMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseResetMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ResetMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseResetMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ResetMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static ResetMsg DecodeFrom(ref BebopReader reader) {

      var record = new ResetMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.GhostResetPoints = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
              for (var i0 = 0; i0 < length0; i0++) {
                string k0;
                BasePosition v0;
                k0 = reader.ReadString();
                v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
                record.GhostResetPoints.Add(k0, v0);
              }
            }
            break;
          case 2:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.PlayerResetPoints = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
              for (var i0 = 0; i0 < length0; i0++) {
                System.Guid k0;
                BasePosition v0;
                k0 = reader.ReadGuid();
                v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
                record.PlayerResetPoints.Add(k0, v0);
              }
            }
            break;
          case 3:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.PlayerLives = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
              for (var i0 = 0; i0 < length0; i0++) {
                System.Guid k0;
                long v0;
                k0 = reader.ReadGuid();
                v0 = reader.ReadInt64();
                record.PlayerLives.Add(k0, v0);
              }
            }
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseResetMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.GhostResetPoints = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
              for (var i0 = 0; i0 < length0; i0++) {
                string k0;
                BasePosition v0;
                k0 = reader.ReadString();
                v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
                record.GhostResetPoints.Add(k0, v0);
              }
            }
            break;
          case 2:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.PlayerResetPoints = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
              for (var i0 = 0; i0 < length0; i0++) {
                System.Guid k0;
                BasePosition v0;
                k0 = reader.ReadGuid();
                v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
                record.PlayerResetPoints.Add(k0, v0);
              }
            }
            break;
          case 3:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.PlayerLives = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
              for (var i0 = 0; i0 < length0; i0++) {
                System.Guid k0;
                long v0;
                k0 = reader.ReadGuid();
                v0 = reader.ReadInt64();
                record.PlayerLives.Add(k0, v0);
              }
            }
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseNetworkMessage : System.IEquatable<BaseNetworkMessage> {
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public uint? IncomingOpCode { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public ImmutableArray<byte> IncomingRecord { get; set; }
    #nullable disable

    public bool Equals(BaseNetworkMessage other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return IncomingOpCode == other.IncomingOpCode && (IncomingRecord == null ? other.IncomingRecord == null : other.IncomingRecord != null && IncomingRecord.SequenceEqual(other.IncomingRecord));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseNetworkMessage baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (IncomingOpCode is not null) hash ^= IncomingOpCode.Value.GetHashCode();
      if (IncomingRecord != null) hash ^= IncomingRecord.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseNetworkMessage left, BaseNetworkMessage right) => Equals(left, right);
    public static bool operator !=(BaseNetworkMessage left, BaseNetworkMessage  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class NetworkMessage : BaseNetworkMessage {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseNetworkMessage record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseNetworkMessage record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseNetworkMessage record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.IncomingOpCode is not null) {
        writer.WriteByte(1);
        writer.WriteUInt32(record.IncomingOpCode.Value);
      }

      if (record.IncomingRecord != null) {
        writer.WriteByte(2);
        writer.WriteBytes(record.IncomingRecord);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static NetworkMessage DecodeFrom(ref BebopReader reader) {

      var record = new NetworkMessage();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.IncomingOpCode = reader.ReadUInt32();
            break;
          case 2:
            record.IncomingRecord = reader.ReadBytes();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseNetworkMessage, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.IncomingOpCode = reader.ReadUInt32();
            break;
          case 2:
            record.IncomingRecord = reader.ReadBytes();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BasePosition : System.IEquatable<BasePosition> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public int X { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public int Y { get; set; }

    public bool Equals(BasePosition other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return X == other.X && Y == other.Y;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BasePosition baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= X.GetHashCode();
      hash ^= Y.GetHashCode();
      return hash;
    }

    public static bool operator ==(BasePosition left, BasePosition right) => Equals(left, right);
    public static bool operator !=(BasePosition left, BasePosition  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class Position : BasePosition {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BasePosition record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BasePosition record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BasePosition record, ref BebopWriter writer) {
      writer.WriteInt32(record.X);
      writer.WriteInt32(record.Y);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Position DecodeFrom(ref BebopReader reader) {

      int field0;
      field0 = reader.ReadInt32();
      int field1;
      field1 = reader.ReadInt32();
      return new Position {
        X = field0,
        Y = field1,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BasePosition, new() {
      int field0;
      field0 = reader.ReadInt32();
      int field1;
      field1 = reader.ReadInt32();
      return new T {
        X = field0,
        Y = field1,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseSessionMsg : System.IEquatable<BaseSessionMsg> {
    public const uint OpCode = 0x2;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public string? SessionId { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public System.Guid? ClientId { get; set; }
    #nullable disable

    public bool Equals(BaseSessionMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return SessionId == other.SessionId && ClientId == other.ClientId;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseSessionMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (SessionId is not null) hash ^= SessionId.GetHashCode();
      if (ClientId is not null) hash ^= ClientId.Value.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseSessionMsg left, BaseSessionMsg right) => Equals(left, right);
    public static bool operator !=(BaseSessionMsg left, BaseSessionMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class SessionMsg : BaseSessionMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseSessionMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseSessionMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseSessionMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.SessionId is not null) {
        writer.WriteByte(1);
        writer.WriteString(record.SessionId);
      }

      if (record.ClientId is not null) {
        writer.WriteByte(2);
        writer.WriteGuid(record.ClientId.Value);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static SessionMsg DecodeFrom(ref BebopReader reader) {

      var record = new SessionMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.SessionId = reader.ReadString();
            break;
          case 2:
            record.ClientId = reader.ReadGuid();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseSessionMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.SessionId = reader.ReadString();
            break;
          case 2:
            record.ClientId = reader.ReadGuid();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
}
